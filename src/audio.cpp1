#include <QByteArray>
#include <QDataStream>
#include <QCoreApplication>
#include <QAudioOutput>
#include <QTimer>
#include <QtCore>


QByteArray generatePCM()
{
    //幅度，因为sampleSize = 16bit
    qint16 amplitude = INT16_MAX;
    //单声道
    int channels = 1;
    //采样率
    int samplerate = 8000;
    //持续时间ms
    int duration = 20;
    //总样本数
    int n_samples = int(channels * samplerate * (duration / 1000.0));
    //声音频率
    int frequency = 100;

    bool reverse = false;
    QByteArray data;
    QDataStream out(&data, QIODevice::WriteOnly);
    out.setByteOrder(QDataStream::LittleEndian);
    for (int i = 0; i < 1000; i++) {
        for (int j = 0; j < n_samples; j++) {
            qreal radians = qreal(2.0 * M_PI * j  * frequency / qreal(samplerate));
            qint16 sample = qint16(qSin(radians) * amplitude);
            out << sample;
        }

        if (!reverse) {
            if (frequency < 2000) {
                frequency += 100;
            } else reverse = true;
        } else {
            if (frequency > 100) {
                frequency -= 100;
            } else reverse = false;
        }
    }

//    QFile file("raw");
//    file.open(QIODevice::WriteOnly);
//    file.write(data);
//    file.close();

    return data;
}

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    QByteArray pcm1 = generatePCM();

    QAudioFormat format;
    format.setCodec("audio/pcm");
    format.setSampleRate(8000);
    format.setSampleSize(16);
    format.setSampleType(QAudioFormat::SignedInt);
    format.setChannelCount(1);
    format.setByteOrder(QAudioFormat::LittleEndian);

    QAudioOutput output(format, qApp);
    QIODevice *device = output.start();

    QTimer *timer_play = new QTimer(qApp);
    timer_play->setTimerType(Qt::PreciseTimer);
    QObject::connect(timer_play, &QTimer::timeout, [&]{
        if (pcm1.size() > 0) {
            int readSize = output.periodSize();
            int chunks = output.bytesFree() / readSize;
            while (chunks) {
                QByteArray samples = pcm1.mid(0, readSize);
                int len = samples.size();
                pcm1.remove(0, len);

                if (len) device->write(samples);
                if (len != readSize) break;

                chunks--;
            }
        }
    });
    timer_play->start(100);

    return a.exec();
}